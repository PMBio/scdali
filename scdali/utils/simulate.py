"""Simulate data from GP with binomial and beta-binomial likelihoods."""


import numpy as np

from scdali.utils.matop import atleast_2d_column, preprocess_clusters
from scdali.utils.stats import logistic


def simulate_beta_binomial(K, D, sigma2, theta, mu=0, invlink=logistic, seed=None):
    """Simulates from binomial Gaussian process with Beta latent noise.

    Args:
        K: Cell-state kernel, for example as generated by create_linear_kernel
            or create_rbf_kernel.
        D: Array of total counts.
        sigma2: Kernel variance component.
        theta: Overdispersion parameter. If zero, sample from a regular Binomial
            distribution instead.
        mu: Latent mean. Defaults to zero, which corresponds to a binomial mean
            of 0.5.
        invlink: Inverse link function. Defaults to invlogit.
        seed: Random seed.

    Returns:
        List with alternative counts, latent rates as well as sampled binomial
        means.
    """
    D = atleast_2d_column(D)

    n, p = D.shape
    rng = np.random.default_rng(seed)

    if sigma2 == 0:
        latent = mu * np.ones((n, p))
    else:
        mu = mu * np.ones((n, 1))
        latent = _sample_normal(p, mu, sigma2*K, rng)
    beta_mean = invlink(latent)
    if theta > 0:
        binomial_mean = rng.beta(a=beta_mean / theta, b=(1-beta_mean) / theta)
    else:
        binomial_mean = beta_mean
    a = rng.binomial(n=D, p=binomial_mean)
    return {'A': a, 'beta_mean': beta_mean, 'binomial_mean': binomial_mean}


def _sample_normal(p, loc, cov, rng):
    """Samples from multivariate normal.

    Attempts fast sampling based on the Cholesky decomposition of the covariance
    matrix instead of SVD (numpy default). If the matrix is not positive
    definite, the Cholesky decomposition will fail in which case this method
    reverts to the numpy default.

    Args:
        p: Number of samples
        loc: Mean of the multivariate Normal.
        cov: Covariance matrix. Has to be positive semi-definite.
        rng: Random number generator.

    Returns:
        Samples from multivariate Normal distribution.
    """
    n = cov.shape[0]
    try:
        L = np.linalg.cholesky(cov)
        return loc + L @ rng.standard_normal(size=(n, p))
    except np.linalg.LinAlgError as err:
        print('Cholesky decomposition failed (%s). Reverting to numpy default.' % err)
        return rng.multivariate_normal(mean=loc.flatten(), cov=cov, size=p).T


def create_cluster_kernel(clusters):
    """Creates block diagonal covariance matrix for clustered data.

    Args:
        clusters: Cluster labels.

    Returns:
        Kernel matrix.
    """
    clusters, _ = preprocess_clusters(clusters)
    return np.eye(clusters.max() + 1)[clusters, :][:, clusters]


def create_rbf_kernel(E, lengthscale=1):
    """Creates radial basis kernel matrix."""
    E = atleast_2d_column(E)
    E_norm = np.sum(E ** 2, axis = -1)
    l = - 1 / lengthscale ** 2
    K = np.exp(l * (E_norm[:, None] + E_norm[None, :] - 2 * np.dot(E, E.T)))
    return K


def create_linear_kernel(E):
    """Creates linear kernel matrix."""
    return E @ E.T

